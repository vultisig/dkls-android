/*
 * Generated by cbindgen Do not edit directly.
 */

#ifndef _GO_SCHNORR_H
#define _GO_SCHNORR_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#define DEFAULT_TTL (60 * 10)

typedef enum lib_error {
  LIB_OK,
  LIB_INVALID_HANDLE,
  LIB_HANDLE_IN_USE,
  LIB_INVALID_HANDLE_TYPE,
  LIB_NULL_PTR,
  LIB_INVALID_BUFFER_SIZE,
  LIB_INVALID_SESSION_STATE,
  LIB_UNKNOWN_ERROR,
  LIB_SERIALIZATION_ERROR,
  LIB_INVALID_DERIVATION_PATH_STR,
  LIB_DERIVATION_ERROR,
  LIB_SETUP_MESSAGE_VALIDATION,
  LIB_NON_EMPTY_OUTPUT_BUFFER,
  LIB_SIGNGEN_ERROR,
  LIB_KEYGEN_ERROR,
  LIB_KEY_EXPORT_ERROR,
  LIB_ABORT_PROTOCOL_PARTY_1 = 100,
  LIB_ABORT_PROTOCOL_PARTY_2,
  LIB_ABORT_PROTOCOL_PARTY_3,
  LIB_ABORT_PROTOCOL_PARTY_4,
  LIB_ABORT_PROTOCOL_PARTY_5,
  LIB_ABORT_PROTOCOL_PARTY_6,
  LIB_ABORT_PROTOCOL_PARTY_7,
  LIB_ABORT_PROTOCOL_PARTY_8,
  LIB_ABORT_PROTOCOL_PARTY_9,
  LIB_ABORT_PROTOCOL_PARTY_10,
} lib_error;

typedef struct tss_buffer {
  const uint8_t *ptr;
  uintptr_t len;
} tss_buffer;

typedef struct go_slice {
  const uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} go_slice;

typedef struct Handle {
  int32_t _0;
} Handle;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void tss_buffer_free(struct tss_buffer *buf);

/*
 Generates a new DKG setup message for Schnorr MPC protocol

 # Arguments

 * `threshold` - t parameter for the MPC threshold protocol: t minimum nodes are needed to sign. t-1 degree polynomial
 * `key_id` - unique identifier of all keyshares: currently hash of public key
 * `ids` - human readable party identifiers.
 * `setup_msg` - The returned setup msg as a tss_buffer

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.
 */
enum lib_error schnorr_keygen_setupmsg_new(uint32_t threshold,
                                           const struct go_slice *key_id,
                                           const struct go_slice *ids,
                                           struct tss_buffer *setup_msg);

/*
 Creates a key generation session from an encoded setup message for Schnorr

 # Arguments

 * `setup` - A reference of encoded setup message
 * `id` - human readable party identifier.
 * `hnd` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error schnorr_keygen_session_from_setup(const struct go_slice *setup,
                                                 const struct go_slice *id,
                                                 struct Handle *hnd);

/*
 Creates a key refresh session from a encoded setup message.

 # Arguments

 * `setup` - A reference of encoded setup message
 * `id` - human readable party identifier.
 * `old_keyshare` -
 * `hnd` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error schnorr_key_refresh_session_from_setup(const struct go_slice *setup,
                                                      const struct go_slice *id,
                                                      struct Handle old_keyshare,
                                                      struct Handle *hnd);

/*
 Transition the Schnorr MPC statemachine on an input message
 # Arguments

 * `session` - The session handler for that specific Schnorr DKG protocol
 * `message` - The message to be passed as input to the statemaching of MPC Execution state machine
 * `finished` - (return) The MPC new state machine after the input message has been applied

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 */
enum lib_error schnorr_keygen_session_input_message(struct Handle session,
                                                    const struct go_slice *message,
                                                    int32_t *finished);

/*
 Receive an output message for the Schnorr MPC statemachine

 # Arguments

 * `session`: session handler

 * `message`: mutable reference to an empty `tss_buffer`.

 # Errors

 * `LIB_NULL_PTR`: passed `message` is null pointer

 * `LIB_NON_EMPTY_OUTPUT_BUFFER`: passed `message is not empty buffer

 */
enum lib_error schnorr_keygen_session_output_message(struct Handle session,
                                                     struct tss_buffer *message);

/*
 Returns a receiver of a message. Tailored for Vultisig
 */
enum lib_error schnorr_keygen_session_message_receiver(struct Handle session,
                                                       const struct go_slice *message,
                                                       uint32_t index,
                                                       struct tss_buffer *receiver);

/*
 Finish the session and collect the generated key share for Schnorr.
 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `schnorr_keygen_session_free()` must be called to free the session handler.

 # Arguments:

 * `session`: key generation session handler

 * `keyshare`: output keyshare handler pointer

 # Errors:

 * `LIB_NULL_PTR`: keyshare is null pointer

 * `LIB_INVALID_HANDLE`: passed invalid key generation session handler.

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_PARTY_{1,2,3}`: Execution was aborted by the
   designated party.

 * `LIB_KEYGEN_ERROR`: An key generation protocol error.

 */
enum lib_error schnorr_keygen_session_finish(struct Handle session, struct Handle *keyshare);

/*
 Deallocate session handler and associated memory.

 # Arguments:

 * `session`: key generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error schnorr_keygen_session_free(const struct Handle *session);

enum lib_error schnorr_presign_from_bytes(const struct go_slice *buf, struct Handle *hnd);

enum lib_error schnorr_presign_to_bytes(struct Handle share, struct tss_buffer *buf);

enum lib_error schnorr_presign_session_id(struct Handle share, struct tss_buffer *buf);

enum lib_error schnorr_keyshare_from_bytes(const struct go_slice *buf, struct Handle *hnd);

enum lib_error schnorr_keyshare_to_bytes(struct Handle share, struct tss_buffer *buf);

enum lib_error schnorr_keyshare_public_key(struct Handle share, struct tss_buffer *buf);

enum lib_error schnorr_keyshare_key_id(struct Handle share, struct tss_buffer *buf);

/*
 Returns key_id from encoded setup message.

 # Arguments

 * `setup` - An encoded setup message.
 * `key_id` - A mutable reference to the buffer where the `key_id` will be stored.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` if `key_id` is `None`.
 * `LIB_INVALID_HANDLE` if `setup` is invalid handle.
 */
enum lib_error schnorr_decode_key_id(const struct go_slice *setup, struct tss_buffer *key_id);

enum lib_error schnorr_decode_session_id(const struct go_slice *setup, struct tss_buffer *message);

enum lib_error schnorr_decode_message(const struct go_slice *setup, struct tss_buffer *message);

enum lib_error schnorr_decode_party_name(const struct go_slice *setup,
                                         uint32_t index,
                                         struct tss_buffer *message);

/*
 Generate new DSG setup message.
 */
enum lib_error schnorr_sign_setupmsg_new(const struct go_slice *key_id,
                                         const struct go_slice *chain_path,
                                         const struct go_slice *message,
                                         const struct go_slice *ids,
                                         struct tss_buffer *setup_msg);

/*
 Generate new DSG Finish setup message.
 */
enum lib_error schnorr_finish_setupmsg_new(const struct go_slice *session_id,
                                           const struct go_slice *message,
                                           const struct go_slice *ids,
                                           struct tss_buffer *setup_msg);

/*
 Create a full sign session from the decoded setup message.

 # Arguments:

 * `setup`: Decoded setup message handle, which will be deallocated by
   this call.

 * `id`: The identifier of a signer.

 * `share_or_presign`: Key share or PreSign handle. Depending of type of
   passed object, the function will create a different type of session.

 * `hnd`: Output pointer to the allocated key generation session handle.

 # Errors:

 * `LIB_INVALID_HANDLE`: One or more of the passed handles is invalid.

 * `LIB_NULL_PTR`: `hnd` is a null pointer.

 * `LIB_SETUP_MESSAGE_VALIDATION`: Setup message validation failed.

 */
enum lib_error schnorr_sign_session_from_setup(const struct go_slice *setup,
                                               const struct go_slice *id,
                                               struct Handle share_or_presign,
                                               struct Handle *hnd);

/*
 Process an input message
 */
enum lib_error schnorr_sign_session_input_message(struct Handle session,
                                                  const struct go_slice *message,
                                                  uint32_t *finished);

/*
 Receive an output message.

 # Arguments

 * session: session handler

 * message: mutable reference to an empty `tss_buffer`.

 # Errors

 * LIB_NULL_PTR: passed `message` is null pointer

 * LIB_NON_EMPTY_OUTPUT_BUFFER: passed `message is not empty buffer

 */
enum lib_error schnorr_sign_session_output_message(struct Handle session,
                                                   struct tss_buffer *message);

/*
 Returns a receiver of a message.
 */
enum lib_error schnorr_sign_session_message_receiver(struct Handle session,
                                                     const struct go_slice *message,
                                                     uint32_t index,
                                                     struct tss_buffer *receiver);

/*
 Finish the session and collect the generated value.

 For full or final sessions, this is an EdDSA signature: [ R || S ].
 For a pre-sign session, it is the serialization of the pre-signature object.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `schnorr_sign_session_free()` must be called to free the session handler.

 # Arguments

 * `session`: signature generation session handler

 * `output`: pointer to output value buffer

 # Errors:

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_PARTY_{1,2,3}`: Execution was aborted by the
   designated party.

 * `LIB_SIGNGEN_ERROR`: An MPC protocol error.

 */
enum lib_error schnorr_sign_session_finish(struct Handle session, struct tss_buffer *output);

/*
 Deallocate session handle and associated memory.

 # Arguments:

 * `session`: signature generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error schnorr_sign_session_free(const struct Handle *session);

/*
 Creates a key export receiver session and generate setup message for
 key exporters.

 # Arguments

 * `share` - Key share handle

 * `ids` - human readable party identifier.

 * `setup_msg` - Buffer for the setup message

 * `session` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - passed a null pointer

 */
enum lib_error schnorr_key_export_receiver_new(struct Handle share,
                                               const struct go_slice *ids,
                                               struct tss_buffer *setup_msg,
                                               struct Handle *session);

/*
 Handle input message from a key exporter.
 Flag `finished` will be set to 1 if the input message
 is last for the session.

 # Arguments

 * `session` - Key export receiver session handle

 * `message` - Buffer with an input message

 * `finished` - pointer to a finished flag

 */
enum lib_error schnorr_key_export_receiver_input_message(struct Handle session,
                                                         const struct go_slice *message,
                                                         int32_t *finished);

/*
 Finish key export receiver session.

 # Arguments

 * `session` - Key export receiver session handle

 * `secret` - pointer to buffer for a exported private key

 */
enum lib_error schnorr_key_export_receiver_finish(struct Handle session, struct tss_buffer *secret);

/*
 Key share export.

 Decode the setup message and encrypt share of private key for
 the key export receiver session.

 # Arguments

 * `share` - Key share handle

 * `id` - human readable identifier

 * `setup` - Setup message generated by `schnorr_key_export_receiver_new()`

 * `message` - encrypted message

 * `receiver` - key export receiver session handle

 */
enum lib_error schnorr_key_exporter(struct Handle share,
                                    const struct go_slice *id,
                                    const struct go_slice *setup,
                                    struct tss_buffer *message,
                                    struct tss_buffer *receiver);

/*
 Creates a key import receiver session and generate setup message for
 key importers.

 # Arguments

 * `private_key`

 * `threshold`

 * `ids` - human readable party identifiers.

 * `setup_msg` - Buffer for the setup message

 * `session` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - passed a null pointer

 */
enum lib_error schnorr_key_import_initiator_new(const struct go_slice *private_key,
                                                uint8_t threshold,
                                                const struct go_slice *ids,
                                                struct tss_buffer *setup_msg,
                                                struct Handle *session);

enum lib_error schnorr_key_importer_new(const struct go_slice *setup,
                                        const struct go_slice *id,
                                        struct Handle *session);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* _GO_SCHNORR_H */
